<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniVerilogSim - Verilog Simulator GUI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .panel h2 {
            color: #1e3c72;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid #2a5298;
            padding-bottom: 10px;
        }

        textarea {
            width: 100%;
            height: 300px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #2a5298;
            box-shadow: 0 0 5px rgba(42, 82, 152, 0.3);
        }

        button {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 15px;
            width: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(42, 82, 152, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        #output {
            background: #f5f5f5;
            height: 300px;
            overflow-y: auto;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .error {
            color: #d32f2f;
            background: #ffebee;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .success {
            color: #388e3c;
            background: #e8f5e9;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .netlist-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .netlist-table th,
        .netlist-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        .netlist-table th {
            background: #f5f5f5;
            font-weight: bold;
            color: #1e3c72;
        }

        .netlist-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        .netlist-table tr:hover {
            background: #f0f0f0;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            header h1 {
                font-size: 1.8em;
            }
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #2a5298;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2a5298;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* --- ×¡×’× ×•× ×•×ª ×—×“×©×™× ×œ×”×™×œ×” ×•×—×œ×•×Ÿ ×§×•×¤×¥ --- */
        .wire-glow-1 {
            filter: drop-shadow(0 0 4px #4CAF50) drop-shadow(0 0 6px #4CAF50);
            cursor: pointer;
            transition: filter 0.2s;
        }

        .wire-glow-0 {
            filter: drop-shadow(0 0 4px #f44336) drop-shadow(0 0 6px #f44336);
            cursor: pointer;
            transition: filter 0.2s;
        }

        /* NEW: Highlight on click - ×¨×§ ××©× ×” ××ª ×”×”×™×œ×” ×œ×¦×”×•×‘! */
        .wire-highlight {
            filter:
                drop-shadow(0 0 3px rgba(255, 235, 59, 1)) drop-shadow(0 0 8px rgba(255, 235, 59, 1)) drop-shadow(0 0 14px rgba(255, 235, 59, 1)) !important;
            cursor: pointer;
        }

        #wire-tooltip {
            position: fixed;
            /* ×©×™× ×•×™ ×œ-fixed ×œ××™×§×•× ×™×¦×™×‘ ×™×•×ª×¨ */
            visibility: hidden;
            background-color: #2c3e50;
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            z-index: 1000;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border: 1px solid #3498db;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-width: 350px;
            line-height: 1.4;
        }

        /* ×¡×’× ×•×Ÿ ×œ××©×ª× ×™× ×‘×ª×•×š ×”×‘×™×˜×•×™ - × ×™×ª×Ÿ ×œ×¨×™×—×•×£ */
        .expr-var {
            font-weight: bold;
            color: #f1c40f;
            /* ×¦×‘×¢ ×–×”×‘ */
            border-bottom: 1px dashed #f1c40f;
            padding: 0 2px;
            cursor: help;
            pointer-events: all;
            /* ×××¤×©×¨ ××™× ×˜×¨××§×¦×™×” ×¢×œ ×”××©×ª× ×” ×‘×ª×•×š ×”-tooltip */
        }
    </style>
</head>

<body>
    <div id="wire-tooltip"></div>

    <div class="container">
        <header>
            <h1>ğŸ”Œ MiniVerilogSim</h1>
            <p>Verilog Circuit Simulator</p>
        </header>

        <div class="main-content">
            <div class="panel">
                <h2>ğŸ“ Verilog Input</h2>
                <textarea id="verilogInput" placeholder="Enter your Verilog code here...
Example:
module and_gate(input a, b, output y);
  assign y = a & b;
endmodule"></textarea>
                <button onclick="analyzeVerilog()">Analyze & Generate Netlist</button>
            </div>

            <div class="panel">
                <h2>ğŸ“Š Netlist Output</h2>
                <div id="output">Ready to analyze...</div>
            </div>
        </div>

        <div class="panel">
            <h2>ğŸ“ˆ Netlist Details</h2>
            <div id="netlsitContainer"></div>
        </div>

        <div class="panel">
            <h2>ğŸ”Œ Circuit Diagram</h2>
            <svg id="circuitDiagram" width="100%" height="800"
                style="border: 1px solid #ddd; border-radius: 4px; background: #f9f9f9;" viewBox="0 0 1400 700"></svg>
        </div>

        <div class="panel">
            <h2>âš¡ Simulation - Input Values</h2>
            <div id="inputsContainer">No inputs detected. Please analyze a circuit first.</div>
            <button onclick="runSimulation()" id="simulateBtn" style="display:none;">â–¶ï¸ Run Simulation</button>
        </div>

        <div class="panel">
            <h2>ğŸ“¤ Wire Values</h2>
            <div id="valuesContainer" style="background: #f5f5f5; padding: 15px; border-radius: 4px;">Awaiting
                simulation...</div>
        </div>
    </div>

    <script async type="module">
        // Load Wasm module as ES6 module
        import VerilogSimModule from './VerilogSimWasm.js';

        let Module = null;

        // --- GLOBAL STATE ---
        let wireValues = {};
        let wireExpressions = {}; // Will hold the logical expression for each wire
        let varTooltip = null; // Tooltip for variables inside the expression
        let hideTimeout = null;
        let highlightedWireName = null; // NEW: Tracks the currently yellow-highlighted wire
        const tooltip = document.getElementById('wire-tooltip');

        if (tooltip) {
            // ×›×©× ×›× ×¡×™× ×œ-Tooltip, ××‘×˜×œ×™× ××ª ×˜×™×™××¨ ×”×¡×’×™×¨×” ×©×œ ×”×—×•×˜
            tooltip.onmouseover = () => {
                clearTimeout(hideTimeout);
            };

            // ×›×©×™×•×¨×“×™× ××”-Tooltip, ××¤×¢×™×œ×™× ×©×•×‘ ××ª ×˜×™×™××¨ ×”×¡×’×™×¨×”
            tooltip.onmouseout = () => {
                hideTimeout = setTimeout(hideTooltip, 100);
            };
        }
        // ------------------------

        // Initialize the module
        VerilogSimModule().then(m => {
            Module = m;
            console.log('âœ“ Wasm module loaded successfully');
            document.getElementById('output').innerHTML = '<span class="success">âœ“ Wasm module ready</span>';

            // Auto-load cute_gates example
            const cuteGatesCode = `module cute_gates (
    input wire a,
    input wire b,
    input wire c,
    input wire d,
    output wire y_and,
    output wire y_or,
    output wire y_xor,
    output wire y_mix
);
    wire ab_and;
    wire cd_or;
    wire not_d;
    assign ab_and = a & b;
    assign cd_or = c | d;
    assign y_xor = a ^ c;
    assign not_d = ~d;
    assign y_and = ab_and;
    assign y_or = cd_or;
    assign y_mix = ab_and ^ cd_or;
endmodule`;

            document.getElementById('verilogInput').value = cuteGatesCode;

            // Auto-analyze
            setTimeout(() => {
                window.analyzeVerilog();
            }, 500);
        }).catch(err => {
            console.error('âœ— Failed to load Wasm module:', err);
            document.getElementById('output').innerHTML = '<span class="error">âœ— Failed to load Wasm module: ' + err.message + '</span>';
        });

        // Make analyzeVerilog accessible globally
        window.analyzeVerilog = async function () {
            const verilogCode = document.getElementById('verilogInput').value;
            const outputDiv = document.getElementById('output');

            if (!verilogCode.trim()) {
                outputDiv.innerHTML = '<span class="error">âŒ Error: Please enter Verilog code</span>';
                return;
            }

            try {
                outputDiv.innerHTML = '<div class="loading"><span class="spinner"></span> Analyzing...</div>';

                // Wait for Module to be ready
                if (!Module || !Module.generateNetlistJson) {
                    outputDiv.innerHTML = '<span class="error">âŒ Error: Wasm module not yet loaded. Please refresh and try again.</span>';
                    console.error('Module not ready:', Module);
                    return;
                }

                // Call the Wasm function
                let resultJson;
                try {
                    resultJson = Module.generateNetlistJson(verilogCode);
                } catch (wasmError) {
                    console.error('Wasm call error:', wasmError);
                    outputDiv.innerHTML = `<span class="error">âŒ Wasm Error: ${wasmError.message || wasmError}</span>`;
                    return;
                }

                // Parse the result
                let result;
                try {
                    result = JSON.parse(resultJson);
                } catch (parseError) {
                    console.error('JSON parse error:', parseError);
                    console.error('Raw result:', resultJson);
                    outputDiv.innerHTML = `<span class="error">âŒ Parse Error: ${parseError.message}<br>Raw output: ${resultJson}</span>`;
                    return;
                }

                // Check for errors in the result
                if (result.error) {
                    outputDiv.innerHTML = `<span class="error">âŒ Parsing Error:<br><br>${escapeHtml(result.error)}</span>`;
                    console.error('Parse error from C++:', result.error);
                } else if (!result.netlist) {
                    outputDiv.innerHTML = `<span class="error">âŒ Error: No netlist generated<br><br>Response: ${JSON.stringify(result, null, 2)}</span>`;
                } else {
                    // Display raw JSON
                    outputDiv.innerHTML = `<span class="success">âœ“ Analysis Complete</span>\n\n<pre>${JSON.stringify(result, null, 2)}</pre>`;

                    // Display netlist as table
                    if (result.netlist && result.netlist.length > 0) {
                        window.displayNetlistTable(result.netlist);
                    } else {
                        console.warn('Empty netlist generated');
                    }
                }
            } catch (error) {
                console.error('Unexpected error:', error);
                outputDiv.innerHTML = `<span class="error">âŒ Unexpected Error:<br><br>${escapeHtml(error.message || String(error))}<br><br><small>Check console for details</small></span>`;
            }
        };

        // Utility function to escape HTML
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        let currentNetlist = [];

        window.displayNetlistTable = function (netlist) {
            currentNetlist = netlist;
            const container = document.getElementById('netlsitContainer');
            let html = '<table class="netlist-table"><thead><tr><th>Output</th><th>Type</th><th>Inputs</th></tr></thead><tbody>';

            netlist.forEach(component => {
                const inputs = component.inputs.join(', ') || 'N/A';
                html += `<tr><td>${component.output}</td><td>${component.type}</td><td>${inputs}</td></tr>`;
            });

            html += '</tbody></table>';
            container.innerHTML = html;

            // Also draw the circuit diagram
            window.drawCircuitDiagram(netlist);

            // Generate input fields
            window.generateInputFields(netlist);
        };

        window.drawCircuitDiagram = function (netlist) {
            console.log('Drawing circuit with netlist:', netlist);

            const svg = document.getElementById('circuitDiagram');
            if (!svg || netlist.length === 0) return;

            while (svg.firstChild) svg.removeChild(svg.firstChild);

            const width = svg.clientWidth || 1400;
            const height = svg.clientHeight || 800;

            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bg.setAttribute('width', width);
            bg.setAttribute('height', height);
            bg.setAttribute('fill', '#fafafa');
            svg.appendChild(bg);

            // Build gate map
            const gatesByOutput = {};
            netlist.forEach(gate => {
                gatesByOutput[gate.output] = gate;
            });

            // Find all inputs and outputs
            const allOutputs = new Set(netlist.map(g => g.output));
            const primaryInputs = new Set();
            netlist.forEach(gate => {
                gate.inputs.forEach(inp => {
                    if (!allOutputs.has(inp)) {
                        primaryInputs.add(inp);
                    }
                });
            });
            const inputs = Array.from(primaryInputs).sort();
            const outputs = Array.from(allOutputs).sort();

            // All wires: inputs + intermediate outputs
            const allWires = new Set(inputs.concat(Array.from(allOutputs)));

            // Create groups
            const railsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            railsGroup.setAttribute('id', 'rails-group');
            svg.appendChild(railsGroup);

            const wiresGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            wiresGroup.setAttribute('id', 'wires-group');
            svg.appendChild(wiresGroup);

            const gatesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gatesGroup.setAttribute('id', 'gates-group');
            svg.appendChild(gatesGroup);

            const portsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            portsGroup.setAttribute('id', 'ports-group');
            svg.appendChild(portsGroup);

            // Calculate depths (producer depth for each wire)
            const depthMemo = {};
            const calculateDepth = (wire) => {
                if (wire in depthMemo) return depthMemo[wire];
                if (!gatesByOutput[wire]) {
                    depthMemo[wire] = 0;
                    return 0;
                }
                const gate = gatesByOutput[wire];
                const inputsDepths = gate.inputs.map(i => calculateDepth(i));
                const d = Math.max(...inputsDepths) + 1;
                depthMemo[wire] = d;
                return d;
            };
            outputs.forEach(o => calculateDepth(o));

            const maxDepth = Math.max(0, ...Object.values(depthMemo));

            // Column X positions: column 0 = inputs, columns 1..maxDepth = gate depths, column maxDepth+1 = outputs column
            const cols = [];
            const leftX = 60;
            const rightX = width - 60;
            const totalCols = Math.max(1, maxDepth + 2);
            const colSpacing = (width - 140) / (totalCols - 1);
            for (let c = 0; c < totalCols; c++) cols.push(60 + c * colSpacing);

            // Y positions: inputs first (ordered), gates arranged per depth and spaced
            const wireY = {};
            const topMargin = 60;
            const bottomMargin = 60;
            const availableHeight = Math.max(200, height - topMargin - bottomMargin);
            const inputSpacing = availableHeight / (Math.max(1, inputs.length) + 1);
            inputs.forEach((inp, idx) => {
                wireY[inp] = topMargin + (idx + 1) * inputSpacing;
            });

            // Place gates per depth and set their output Y (centered for that depth)
            const gatesByDepth = {};
            netlist.forEach(g => {
                const d = depthMemo[g.output] || 0;
                if (!gatesByDepth[d]) gatesByDepth[d] = [];
                gatesByDepth[d].push(g);
            });

            for (let d = 1; d <= maxDepth; d++) {
                const gates = gatesByDepth[d] || [];
                const blockTop = topMargin;
                const blockHeight = availableHeight;
                const spacing = blockHeight / (Math.max(1, gates.length) + 1);
                gates.forEach((g, i) => {
                    const y = blockTop + (i + 1) * spacing;
                    wireY[g.output] = y;
                });
            }

            // â­ NEW: ××™×—×•×“ ××™×§×•××™ Y ×©×œ ×—×•×˜×™ Identity
            netlist.forEach(gate => {
                if (gate.type === 'IDENTITY' && gate.inputs.length === 1) {
                    const inputWire = gate.inputs[0];
                    const outputWire = gate.output;

                    // ×•×•×“× ×©×—×•×˜ ×”×§×œ×˜ ×›×‘×¨ ×××•×§×
                    if (wireY[inputWire] !== undefined) {
                        // ×”×›×¨×— ××ª ×—×•×˜ ×”×¤×œ×˜ ×œ×”×™×•×ª ×‘××•×ª×” ×©×•×¨×ª Y ×›××• ×”×§×œ×˜
                        wireY[outputWire] = wireY[inputWire];
                        // ×©× ×” ×’× ××ª ×”××™×§×•× ×”××•×¤×§×™ ×©×œ ×—×•×˜ ×”×¤×œ×˜ (ProducerX)
                        // ×›×š ×©×”×•× ×™×ª×—×™×œ ×××•×ª×• ××§×•× ×›××• ×”×§×œ×˜, ×•×›×š ×”-Rail ×™×ª××–×’
                        wireProducerX[outputWire] = wireProducerX[inputWire];
                    }
                }
            });
            // For any wire still without Y (rare), place underneath
            let fallbackY = topMargin + availableHeight + 20;
            Array.from(allWires).forEach(w => {
                if (!wireY[w]) {
                    wireY[w] = fallbackY;
                    fallbackY += 24;
                }
            });

            // Producer X (where the wire originates): inputs -> col 0, gate outputs -> their depth column
            const wireProducerX = {};
            inputs.forEach(i => wireProducerX[i] = cols[0]);
            Object.keys(depthMemo).forEach(w => {
                const d = depthMemo[w] || 0;
                wireProducerX[w] = cols[Math.min(d, cols.length - 1)];
            });

            // Compute rightmost consumer X for each wire (where it stops being drawn)
            const wireConsumerX = {};
            Array.from(allWires).forEach(w => {
                let maxX = wireProducerX[w]; // at least extends to producer
                // Check if this wire is an output (primary circuit output)
                if (outputs.includes(w)) {
                    maxX = cols[cols.length - 1];
                } else {
                    // Find all gates that consume this wire
                    netlist.forEach(gate => {
                        if (gate.inputs.includes(w)) {
                            const gateDepth = depthMemo[gate.output] || 0;
                            const gateX = cols[Math.min(gateDepth, cols.length - 1)];
                            maxX = Math.max(maxX, gateX - 45); // tap point slightly before gate
                        }
                    });
                }
                wireConsumerX[w] = maxX;
            });

            // Prepare color palette for gates/segments - ensure each wire gets unique color
            const palette = ['#6a1b9a', '#00897b', '#f57c00', '#43a047', '#1e88e5', '#fb8c00', '#8e24aa', '#e53935', '#c62828', '#00695c', '#bf360c', '#1b5e20', '#ad1457', '#00838f', '#e65100', '#2e7d32', '#283593', '#f57f17'];

            // Assign unique color to each wire (including both inputs and gate outputs)
            const segmentColor = {};
            let colorIdx = 0;

            // First assign colors to primary inputs
            inputs.forEach(inp => {
                segmentColor[inp] = palette[colorIdx % palette.length];
                colorIdx++;
            });

            // Then assign colors to gate outputs
            netlist.forEach(gate => {
                segmentColor[gate.output] = palette[colorIdx % palette.length];
                colorIdx++;
            });

            // Add defs for markers (arrow head) and styling
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrow');
            marker.setAttribute('markerWidth', '8');
            marker.setAttribute('markerHeight', '8');
            marker.setAttribute('refX', '6');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M0,0 L6,3 L0,6 z');
            path.setAttribute('fill', '#333');
            marker.appendChild(path);
            defs.appendChild(marker);
            svg.appendChild(defs);

            // Draw rails for every wire from producer X to its rightmost consumer
            Array.from(allWires).forEach(w => {
                const y = wireY[w];
                const xStart = wireProducerX[w] + 12; // small offset from node
                const xEnd = wireConsumerX[w];

                if (xEnd > xStart) {
                    const rail = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    rail.setAttribute('x1', xStart);
                    rail.setAttribute('y1', y);
                    rail.setAttribute('x2', xEnd);
                    rail.setAttribute('y2', y);
                    rail.setAttribute('stroke', segmentColor[w]); // Use unique segment color
                    rail.setAttribute('stroke-width', '3');
                    rail.setAttribute('stroke-linecap', 'round');
                    rail.setAttribute('data-wire', w);
                    // Add wire glow class here, will be set to 0/1 in setVerilogData
                    rail.classList.add('wire-glow-0');
                    railsGroup.appendChild(rail);
                }

                // small producer circle (colored)
                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                dot.setAttribute('cx', wireProducerX[w]);
                dot.setAttribute('cy', y);
                dot.setAttribute('r', '9');
                dot.setAttribute('fill', segmentColor[w]);
                dot.setAttribute('stroke', '#fff');
                dot.setAttribute('stroke-width', '2');
                portsGroup.appendChild(dot);
            });

            // Helper to draw orthogonal connection from rail to gate input
            function connectRailToGate(wireName, gateX, gateInputY, offsetX = 0) {
                const railY = wireY[wireName];

                const baseTapX = gateX - 40;
                const railTapX = baseTapX - offsetX;

                const color = segmentColor[wireName] || '#999';

                // vertical from railTapX,railY to railTapX,gateInputY
                const v = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                v.setAttribute('x1', railTapX);
                v.setAttribute('y1', railY); // ××ª×—×™×œ ××”-Rail ×”×¨××©×™
                v.setAttribute('x2', railTapX);
                v.setAttribute('y2', gateInputY);
                v.setAttribute('stroke', color); // Use unique segment color
                v.setAttribute('stroke-width', '3');
                v.setAttribute('stroke-linecap', 'round');
                v.setAttribute('data-wire', wireName);
                v.classList.add('wire-glow-0');
                wiresGroup.appendChild(v);

                // short horizontal into gate (lighter stroke)
                const h2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                h2.setAttribute('x1', railTapX);
                h2.setAttribute('y1', gateInputY);
                h2.setAttribute('x2', gateX - 18);
                h2.setAttribute('y2', gateInputY);
                h2.setAttribute('stroke', color); // Use unique segment color
                h2.setAttribute('stroke-width', '3');
                h2.setAttribute('data-wire', wireName);
                h2.classList.add('wire-glow-0');
                wiresGroup.appendChild(h2);

                // junction circle at tap (colored)
                const tap = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                tap.setAttribute('cx', railTapX);
                tap.setAttribute('cy', railY);
                tap.setAttribute('r', '4'); // ×’×•×“×œ ×§×˜×Ÿ ×™×•×ª×¨
                tap.setAttribute('fill', color);
                tap.setAttribute('stroke', '#fff');
                tap.setAttribute('stroke-width', '1.5');
                wiresGroup.appendChild(tap);
            }

            // â­ NEW: Track the number of times each wire's main rail has been tapped
            const depthLaneTracker = {};

            // Draw gates and connect
            netlist.forEach(gate => {
                if (gate.type === 'IDENTITY') {
                    return;
                }
                const d = depthMemo[gate.output] || 0;
                const gX = cols[Math.min(d, cols.length - 1)];
                const gY = wireY[gate.output];

                // ×”×’×“×¨×ª ×§×‘×•×¢×™× ×œ×¨×™×•×•×—
                const LANE_SPACING = 30; // ×¤×™×§×¡×œ×™× ×‘×™×Ÿ ×›×œ ×§×• ×× ×›×™ (×”×’×“×œ× ×• ×›×“×™ ×œ×™×¦×•×¨ ××•×•×™×¨)

                // Draw gate inputs
                gate.inputs.forEach((inp, idx) => {
                    const inputCount = gate.inputs.length;
                    const inputY = gY - 10 + (inputCount === 1 ? 10 : (idx * (20 / Math.max(1, inputCount - 1))));

                    // ×œ×•×’×™×§×” ×—×“×©×”:
                    // ×‘××§×•× ×œ×‘×“×•×§ ×›××” ×¤×¢××™× ×”×©×ª××©× ×• ×‘×—×•×˜ ×”×¡×¤×¦×™×¤×™ ×”×–×”,
                    // ×× ×—× ×• ×‘×•×“×§×™× ×›××” ×§×•×•×™× ×× ×›×™×™× ×›×‘×¨ ×™×© ×‘×¢××•×“×” (depth) ×”×–×• ×‘××•×¤×Ÿ ×›×œ×œ×™.
                    if (!depthLaneTracker[d]) depthLaneTracker[d] = 0;
                    const laneIndex = depthLaneTracker[d]++;

                    // ×—×™×©×•×‘ ×”-Offset: ×›×œ ×§×• ××§×‘×œ × ×ª×™×‘ ××©×œ×•
                    // ×”×•×¡×¤× ×• 20 ×¤×™×§×¡×œ ×‘×¡×™×¡ ×›×“×™ ×œ×”×¨×—×™×§ ×§×¦×ª ××”×©×¢×¨
                    const totalOffsetX = 20 + (laneIndex * LANE_SPACING);

                    // connect rail to this gate input
                    connectRailToGate(inp, gX, inputY, totalOffsetX);
                });

                // Draw gate symbol (×©××¨ ×”×§×•×“ × ×©××¨ ××•×ª×• ×“×‘×¨)
                drawGateSymbol(gatesGroup, gX - 22, gY - 18, gate.type, gate.output);

                // Draw short output stub to rail (colored with gate's segment color)
                const outStub = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                outStub.setAttribute('x1', gX + 25);
                outStub.setAttribute('y1', gY);
                outStub.setAttribute('x2', gX + 40);
                outStub.setAttribute('y2', gY);
                outStub.setAttribute('stroke', segmentColor[gate.output]); // Use unique segment color
                outStub.setAttribute('stroke-width', '3');
                outStub.setAttribute('data-wire', gate.output);
                outStub.classList.add('wire-glow-0');
                wiresGroup.appendChild(outStub);
            });

            // Draw input labels on left
            inputs.forEach(i => {
                const y = wireY[i];
                const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                txt.setAttribute('x', 40);
                txt.setAttribute('y', y + 5);
                txt.setAttribute('text-anchor', 'end');
                txt.setAttribute('font-size', '13');
                txt.setAttribute('font-weight', 'bold');
                txt.setAttribute('fill', '#1976d2');
                txt.textContent = i;
                portsGroup.appendChild(txt);
            });

            // Draw outputs on right (labels and dots)
            outputs.forEach(o => {
                const y = wireY[o];
                const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                dot.setAttribute('cx', cols[cols.length - 1]);
                dot.setAttribute('cy', y);
                dot.setAttribute('r', '6');
                dot.setAttribute('fill', '#66bb6a');
                dot.setAttribute('stroke', '#2e7d32');
                dot.setAttribute('stroke-width', '2');
                portsGroup.appendChild(dot);

                const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                txt.setAttribute('x', cols[cols.length - 1] + 14);
                txt.setAttribute('y', y + 5);
                txt.setAttribute('text-anchor', 'start');
                txt.setAttribute('font-size', '13');
                txt.setAttribute('font-weight', 'bold');
                txt.setAttribute('fill', '#2e7d32');
                txt.textContent = o;
                portsGroup.appendChild(txt);
            });

            console.log('âœ“ Circuit diagram complete');
        };

        function drawWireWithArrow(container, x1, y1, x2, y2, wireLabel) {
            // This function is no longer used - kept for compatibility
        }

        function drawGateSymbol(layer, x, y, gateType, label) {
            const colors = {
                'AND': { fill: '#4CAF50', icon: 'AND' },
                'OR': { fill: '#2196F3', icon: 'OR' },
                'XOR': { fill: '#FF9800', icon: 'XOR' },
                'NOT': { fill: '#F44336', icon: 'Â¬' },
                'NAND': { fill: '#9C27B0', icon: 'NAND' },
                'NOR': { fill: '#00BCD4', icon: 'NOR' },
                'IDENTITY': { fill: '#607D8B', icon: '=' },
                'CONSTANT': { fill: '#795548', icon: 'C' }
            };

            const gateColor = colors[gateType] || { fill: '#2a5298', icon: '?' };

            // Draw different gate shapes
            switch (gateType) {
                case 'AND':
                    // AND gate: curved right side
                    const andPath = `M ${x} ${y} L ${x + 50} ${y} Q ${x + 70} ${y + 25} ${x + 50} ${y + 50} L ${x} ${y + 50} Z`;
                    const andGate = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    andGate.setAttribute('d', andPath);
                    andGate.setAttribute('fill', gateColor.fill);
                    andGate.setAttribute('stroke', '#333');
                    andGate.setAttribute('stroke-width', '2');
                    layer.appendChild(andGate);
                    break;

                case 'OR':
                    // OR gate: curved sides
                    const orPath = `M ${x + 5} ${y} Q ${x + 15} ${y + 25} ${x + 5} ${y + 50} L ${x + 50} ${y + 50} Q ${x + 70} ${y + 25} ${x + 50} ${y} Z`;
                    const orGate = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    orGate.setAttribute('d', orPath);
                    orGate.setAttribute('fill', gateColor.fill);
                    orGate.setAttribute('stroke', '#333');
                    orGate.setAttribute('stroke-width', '2');
                    layer.appendChild(orGate);
                    break;

                case 'XOR':
                    // XOR gate: curved with extra line
                    const xorPath = `M ${x + 5} ${y} Q ${x + 15} ${y + 25} ${x + 5} ${y + 50} L ${x + 50} ${y + 50} Q ${x + 70} ${y + 25} ${x + 50} ${y} Z`;
                    const xorGate = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    xorGate.setAttribute('d', xorPath);
                    xorGate.setAttribute('fill', gateColor.fill);
                    xorGate.setAttribute('stroke', '#333');
                    xorGate.setAttribute('stroke-width', '2');
                    layer.appendChild(xorGate);

                    // Extra curved line for XOR
                    const xorLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    xorLine.setAttribute('d', `M ${x + 2} ${y} Q ${x + 8} ${y + 25} ${x + 2} ${y + 50}`);
                    xorLine.setAttribute('stroke', '#333');
                    xorLine.setAttribute('stroke-width', '2');
                    xorLine.setAttribute('fill', 'none');
                    layer.appendChild(xorLine);
                    break;

                case 'NOT':
                    // NOT gate: triangle
                    const notPath = `M ${x} ${y} L ${x} ${y + 50} L ${x + 50} ${y + 25} Z`;
                    const notGate = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    notGate.setAttribute('d', notPath);
                    notGate.setAttribute('fill', gateColor.fill);
                    notGate.setAttribute('stroke', '#333');
                    notGate.setAttribute('stroke-width', '2');
                    layer.appendChild(notGate);

                    // Circle at output
                    const notCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    notCircle.setAttribute('cx', x + 60);
                    notCircle.setAttribute('cy', y + 25);
                    notCircle.setAttribute('r', '6');
                    notCircle.setAttribute('fill', 'none');
                    notCircle.setAttribute('stroke', '#333');
                    notCircle.setAttribute('stroke-width', '2');
                    layer.appendChild(notCircle);
                    break;

                default:
                    // Default: rounded rectangle
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', y);
                    rect.setAttribute('width', 60);
                    rect.setAttribute('height', 50);
                    rect.setAttribute('rx', '5');
                    rect.setAttribute('fill', gateColor.fill);
                    rect.setAttribute('stroke', '#333');
                    rect.setAttribute('stroke-width', '2');
                    layer.appendChild(rect);
            }

            // Gate label inside
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x + 30);
            text.setAttribute('y', y + 30);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-weight', 'bold');
            text.setAttribute('font-size', '12');
            text.setAttribute('fill', 'white');
            text.textContent = gateColor.icon;
            layer.appendChild(text);
        }

        function drawWire(svg, x1, y1, x2, y2, wireLabel) {
            // This function is no longer used - kept for compatibility
        }

        function getGateColor(gateType) {
            const colors = {
                'AND': '#4CAF50',
                'OR': '#2196F3',
                'XOR': '#FF9800',
                'NOT': '#F44336',
                'NAND': '#9C27B0',
                'NOR': '#00BCD4',
                'IDENTITY': '#607D8B',
                'CONSTANT': '#795548'
            };
            return colors[gateType] || '#2a5298';
        }

        // Generate input fields for the circuit
        window.generateInputFields = function (netlist) {
            const container = document.getElementById('inputsContainer');
            const inputs = new Set();

            // Collect all inputs (wires used but not generated by any gate)
            netlist.forEach(component => {
                component.inputs.forEach(input => {
                    inputs.add(input);
                });
            });

            // Remove outputs that are generated
            netlist.forEach(component => {
                inputs.delete(component.output);
            });

            if (inputs.size === 0) {
                container.innerHTML = '<p style="color: #666;">No inputs found in this circuit.</p>';
                document.getElementById('simulateBtn').style.display = 'none';
                return;
            }

            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">';

            inputs.forEach(input => {
                html += `
                    <div style="border: 1px solid #ddd; padding: 10px; border-radius: 4px;">
                        <label style="font-weight: bold; display: block; margin-bottom: 8px;">${input}</label>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="setInputValue('${input}', 0)" style="flex: 1; padding: 8px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer;">0</button>
                            <button onclick="setInputValue('${input}', 1)" style="flex: 1; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer;">1</button>
                        </div>
                        <div id="value_${input}" style="margin-top: 8px; text-align: center; padding: 5px; background: #f9f9f9; border-radius: 3px; font-weight: bold; color: #333;">?</div>
                    </div>
                `;
            });

            html += '</div>';
            container.innerHTML = html;
            document.getElementById('simulateBtn').style.display = 'block';
        };

        // Store input values
        const inputValues = {};

        window.setInputValue = function (inputName, value) {
            inputValues[inputName] = value;
            document.getElementById('value_' + inputName).textContent = value;

            // Auto-run simulation
            window.runSimulation();
        };

        // Run simulation
        window.runSimulation = function () {
            if (!Module || !Module.simulateCircuit) {
                console.error('Wasm module not ready');
                return;
            }

            const verilogCode = document.getElementById('verilogInput').value;
            const valuesContainer = document.getElementById('valuesContainer');

            try {
                // Call simulation
                const resultJson = Module.simulateCircuit(verilogCode, JSON.stringify(inputValues));
                const result = JSON.parse(resultJson);

                if (result.error) {
                    valuesContainer.innerHTML = `<span class="error">âŒ ${escapeHtml(result.error)}</span>`;
                } else {
                    // Display wire values (HTML list)
                    let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">';

                    for (const [wire, value] of Object.entries(result.values)) {
                        const valueDisplay = value ? '1 âœ“' : '0 âœ—';
                        const color = value ? '#4CAF50' : '#f44336';
                        html += `
                            <div style="border: 2px solid ${color}; padding: 12px; border-radius: 4px; text-align: center;">
                                <div style="font-weight: bold; margin-bottom: 8px; color: #333;">${wire}</div>
                                <div style="font-size: 20px; font-weight: bold; color: ${color};">${valueDisplay}</div>
                            </div>
                        `;
                    }

                    html += '</div>';
                    valuesContainer.innerHTML = html;

                    // --- NEW: Dummy expressions for demonstration ---
                    // NOTE: The C++ (Wasm) side must be updated to return this 'expressions' object.
                    const dummyExpressions = {
                        "a": "INPUT (Pin a)",
                        "b": "INPUT (Pin b)",
                        "c": "INPUT (Pin c)",
                        "d": "INPUT (Pin d)",
                        "ab_and": "a & b",
                        "cd_or": "c | d",
                        "not_d": "~d",
                        "y_xor": "a ^ c",
                        "y_and": "ab_and",
                        "y_or": "cd_or",
                        "y_mix": "ab_and ^ cd_or"
                    };

                    const fullData = {
                        values: result.values,
                        expressions: dummyExpressions // Replace with actual result.expressions when C++ is ready
                    };

                    // Update circuit diagram colors and add interactions
                    window.setVerilogData(fullData);
                }
            } catch (error) {
                console.error('Simulation error:', error);
                valuesContainer.innerHTML = `<span class="error">âŒ ${escapeHtml(error.message)}</span>`;
            }
        };

        // --- NEW FUNCTIONS FOR GLOW AND HOVER INTERACTION ---

        /**
         * ×¤×•× ×§×¦×™×” ×—×™×¦×•× ×™×ª ×©××§×‘×œ×ª ××ª ×”× ×ª×•× ×™× ×”××œ××™× (×¢×¨×›×™× ×•×‘×™×˜×•×™×™×) ××”×¡×™××•×œ×˜×•×¨.
         * @param {Object} data - ××•×‘×™×™×§×˜ ×¢× ×©× ×™ ×××¤×™×™× ×™×: values ×•-expressions
         */
        window.setVerilogData = function (data) {
            if (!data || !data.values) {
                console.error("Invalid data received from simulator (missing values).");
                return;
            }
            // Update global state
            wireValues = data.values;
            // Expressions are mandatory for the new feature, use empty if not provided by Wasm
            wireExpressions = data.expressions || {};

            applyStylingAndInteractions(wireValues);
        };

        /**
         * ××™×™×©× ××ª ×¡×’× ×•× ×•×ª ×”×”×™×œ×” ×•××•×¡×™×£ ×××–×™× ×™× ×œ×¨×™×—×•×£ ×•×œ×—×™×¦×”.
         * @param {Object} values - ××•×‘×™×™×§×˜ ×©×œ ×©× ×—×•×˜ -> ×¢×¨×š (0 ××• 1)
         */
        function applyStylingAndInteractions(values) {
            const svg = document.getElementById('circuitDiagram');
            if (!svg) return;

            // --- NEW: Re-apply Highlight State ---
            // ×©×•××¨ ××ª ××¦×‘ ×”×”×“×’×©×” ×”×¦×”×•×‘×” ×œ×¤× ×™ ×›×œ ×¢×“×›×•×Ÿ
            let needsReHighlight = null;
            if (highlightedWireName) {
                needsReHighlight = highlightedWireName;
                highlightedWireName = null; // ×× ×§×” ×–×× ×™×ª
            }

            // ×”×¡×¨×ª ×›×œ ×ª×•×•×™×•×ª ×”×¢×¨×›×™× ×”×™×©× ×•×ª (××”×œ×•×’×™×§×” ×”×™×©× ×”)
            svg.querySelectorAll('[data-value-label]').forEach(el => el.remove());

            // ×¢×“×›×•×Ÿ ×¦×‘×¢×™ ×”×”×™×œ×” ×•×”×•×¡×¤×ª ×××–×™× ×™ ×¨×™×—×•×£/×œ×—×™×¦×”
            svg.querySelectorAll('#rails-group line, #wires-group line').forEach(line => {
                const wireName = line.getAttribute('data-wire');
                if (wireName && values.hasOwnProperty(wireName)) {
                    const value = values[wireName];

                    // REMOVED: line.setAttribute('stroke', color); // <--- ×œ× ××©× ×™× ××ª ×¦×‘×¢ ×”×§×• ×”×¨××©×™!

                    // ×”×—×œ ×¡×’× ×•×Ÿ ×”×™×œ×” (glow) ×œ×¤×™ ×¢×¨×š (××“×•×/×™×¨×•×§)
                    line.classList.remove('wire-glow-0', 'wire-glow-1');
                    line.classList.add(value ? 'wire-glow-1' : 'wire-glow-0');

                    // ×•×•×“× ×©×”×“×’×©×” ×¦×”×•×‘×” ××•×¡×¨×ª (×ª×—×•×œ ×©×•×‘ ×œ××˜×” ×‘××™×“×ª ×”×¦×•×¨×š)
                    line.classList.remove('wire-highlight');

                    // ×”×•×¡×¤×ª ×××–×™× ×™× ×œ×˜×™×¤×•×œ ×‘×¨×™×—×•×£
                    line.onmouseover = (e) => showTooltip(e, wireName);
                    line.onmousemove = (e) => moveTooltip(e);
                    line.onmouseout = () => {
                        // ×¨×§ ××¤×¢×™×œ ×˜×™×™××¨, ×××¤×©×¨ ××¢×‘×¨ ××”×™×¨
                        hideTimeout = setTimeout(hideTooltip, 100);
                    };

                    // NEW: ×”×•×¡×¤×ª ×××–×™×Ÿ ×œ×—×™×¦×” ×œ×”×“×’×©×” ×¦×”×•×‘×”
                    line.onclick = (e) => window.handleWireClick(wireName);
                }
            });

            // Re-apply the highlight if a wire was highlighted before this function ran
            if (needsReHighlight) {
                // Apply highlight without toggling it off
                svg.querySelectorAll(`#rails-group line[data-wire='${needsReHighlight}'], #wires-group line[data-wire='${needsReHighlight}']`).forEach(line => {
                    line.classList.add('wire-highlight');
                });
                highlightedWireName = needsReHighlight; // Restore state
            }
        }

        // NEW: Handle wire click for yellow highlight
        window.handleWireClick = function (wireName) {
            const svg = document.getElementById('circuitDiagram');

            // 1. Remove highlight from ALL wires
            svg.querySelectorAll('.wire-highlight').forEach(line => {
                line.classList.remove('wire-highlight');
            });

            // 2. Toggle the highlight state
            if (highlightedWireName === wireName) {
                // If clicking the currently highlighted wire, unhighlight it
                highlightedWireName = null;
            } else {
                // Otherwise, highlight the new wire
                svg.querySelectorAll(`#rails-group line[data-wire='${wireName}'], #wires-group line[data-wire='${wireName}']`).forEach(line => {
                    line.classList.add('wire-highlight');
                });
                highlightedWireName = wireName;
            }
        };


        /**
         * ××¦×™×’ ××ª ×”-Tooltip ×”×¨××©×™ ×¢× ×”×‘×™×˜×•×™ ×”×œ×•×’×™.
         */
        function showTooltip(event, wireName) {
            let expr = wireExpressions[wireName] || "××™×Ÿ ×‘×™×˜×•×™ ×–××™×Ÿ. ×™×© ×œ×¢×“×›×Ÿ ××ª ×§×•×“ ×”-C++ (Wasm).";
            let valueStr = wireValues[wireName] !== undefined ? wireValues[wireName] : '?';
            let tooltipContent = `<b>Wire:</b> ${wireName}<br><b>Value:</b> ${valueStr}<hr style="margin: 5px 0; border-color: #3498db;"><b>Logical expression:</b> `;

            // ×”×•×¤×š ×›×œ ×©× ××©×ª× ×” ×‘×‘×™×˜×•×™ ×œ××œ×× ×˜ ×©× ×™×ª×Ÿ ×œ×¨×™×—×•×£ (expr-var)
            let styledExpr = expr.replace(/([A-Za-z0-9_]+)/g, (match) => {
                // ×¨×§ ×× ×–×” ×©× ×©×œ ×—×•×˜ ××—×¨ ×©×™×© ×œ×• ×¢×¨×š, ×”×•×¤×›×™× ××•×ª×• ×œ× ×™×ª×Ÿ ×œ×¨×™×—×•×£
                if (wireValues[match] !== undefined && match !== wireName) {
                    return `<span class="expr-var" data-var-name="${match}">${match}</span>`;
                }
                return match;
            });

            tooltip.innerHTML = tooltipContent + styledExpr;
            tooltip.style.visibility = 'visible';
            moveTooltip(event);

            // ×”×•×¡×¤×ª ×××–×™× ×™ ×¨×™×—×•×£ ×œ×›×œ ××©×ª× ×” ×‘×ª×•×š ×”×‘×™×˜×•×™
            tooltip.querySelectorAll('.expr-var').forEach(span => {
                span.onmouseover = (e) => showVarValue(e, span.getAttribute('data-var-name'));
                span.onmouseout = () => hideVarValue();
            });
        }

        /**
         * ××¦×™×’ ××ª ×”×¢×¨×š ×©×œ ××©×ª× ×” ×¡×¤×¦×™×¤×™ ×‘-Tooltip ××©× ×™.
         */
        function showVarValue(event, varName) {
            if (varTooltip) varTooltip.remove();

            const value = wireValues[varName] !== undefined ? wireValues[varName] : 'N/A';

            varTooltip = document.createElement('div');
            varTooltip.style.cssText = `
                position: fixed; 
                background-color: #34495e;
                color: #ecf0f1;
                padding: 4px 8px;
                border-radius: 3px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                font-size: 0.8em;
                z-index: 1001;
                white-space: nowrap;
                pointer-events: none; /* ×›×“×™ ×œ× ×œ×”×¤×¨×™×¢ ×œ-tooltip ×”×¨××©×™ */
            `;
            varTooltip.innerHTML = `<b>${varName}</b>: ${value}`;
            document.body.appendChild(varTooltip);

            // ××™×§×•× ×”-tooltip ×”××©× ×™ ×œ×™×“ ×¡××Ÿ ×”×¢×›×‘×¨
            varTooltip.style.left = (event.clientX + 15) + 'px';
            varTooltip.style.top = (event.clientY - 25) + 'px';
        }

        /**
         * ××¢×‘×™×¨ ××ª ×”-Tooltip ×”×¨××©×™ ×¢× ×ª× ×•×¢×ª ×”×¢×›×‘×¨.
         */
        function moveTooltip(event) {
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY + 10) + 'px';
        }

        /**
         * ××—×‘×™× ××ª ×”-Tooltip ×”×¨××©×™.
         */
        function hideTooltip() {
            tooltip.style.visibility = 'hidden';
            hideVarValue();
            // ×”×¡×¨×ª ×××–×™× ×™× ×“×™× ××™×™×
            tooltip.querySelectorAll('.expr-var').forEach(span => {
                span.onmouseover = null;
                span.onmouseout = null;
            });
        }

        /**
         * ××—×‘×™× ××ª ×”-Tooltip ×”××©× ×™.
         */
        function hideVarValue() {
            if (varTooltip) {
                varTooltip.remove();
                varTooltip = null;
            }
        }

        // --- END OF NEW FUNCTIONS ---

        // Deprecated: window.updateCircuitDiagramWithValues is no longer needed/correctly used
        // It remains here to avoid breaking unexpected dependencies but its body is empty/simplified
        window.updateCircuitDiagramWithValues = function (values) {
            // This function is now superseded by window.setVerilogData and applyStylingAndInteractions
            // For back-compatibility, we can call the new function if only values are passed
            window.setVerilogData({ values: values, expressions: wireExpressions });
        };

        // Allow Enter key to submit
        document.addEventListener('DOMContentLoaded', function () {
            const input = document.getElementById('verilogInput');
            if (input) {
                input.addEventListener('keydown', function (e) {
                    if (e.ctrlKey && e.key === 'Enter') {
                        window.analyzeVerilog();
                    }
                });
            }
        });
    </script>
</body>

</html>